#!/usr/bin/env python3
import argparse
import json
import os
import shutil
import subprocess
import sys
import hashlib
import tempfile
import stat
import platform
import urllib.request

DEFAULT_PORTAL = 'https://pc4x1xgehc.execute-api.us-west-2.amazonaws.com'
DEFAULT_HELPER_BASE_URL = 'https://github.com/afewell-hh/hh/releases/latest/download'

# Version info - populated by CI build
HH_VERSION = os.environ.get('HH_BUILD_VERSION', 'v0.1.11')
HH_COMMIT = os.environ.get('HH_BUILD_COMMIT', 'unknown')
HH_BUILD_DATE = os.environ.get('HH_BUILD_DATE', 'unknown')

# exit codes
EC_SUCCESS = 0
EC_DOCKER_MISSING = 10
EC_DOCKER_PERMISSION = 11
EC_HELPER_INSTALL_FAILED = 12
EC_BIN_INSTALL_FAILED = 13
EC_CHECKSUM_MISMATCH = 14
EC_DOCKER_SUDO_REQUIRED = 15
EC_SANITY_FAILED = 20

def ensure_hh_dir():
    p = os.path.join(os.path.expanduser('~'), '.hh')
    os.makedirs(p, exist_ok=True)
    return p

def detect_arch():
    """Detect system architecture and return normalized arch string"""
    machine = platform.machine().lower()
    if machine in ('x86_64', 'amd64'):
        return 'linux-amd64'
    elif machine in ('aarch64', 'arm64'):
        return 'linux-arm64'
    else:
        # Fallback for unknown architectures
        return None

def get_default_helper_urls():
    """Get default helper URLs based on detected architecture"""
    arch = detect_arch()

    # Try arch-specific binary first
    if arch:
        helper_url = f"{DEFAULT_HELPER_BASE_URL}/docker-credential-hh-{arch}"
        checksum_url = f"{DEFAULT_HELPER_BASE_URL}/docker-credential-hh-{arch}.sha256"
        return helper_url, checksum_url, arch

    # Fallback to universal shell script
    helper_url = f"{DEFAULT_HELPER_BASE_URL}/docker-credential-hh.sh"
    checksum_url = f"{DEFAULT_HELPER_BASE_URL}/docker-credential-hh.sh.sha256"
    return helper_url, checksum_url, "shell"

def fetch_checksum(checksum_url):
    """Fetch checksum from URL, return None if not available"""
    try:
        with urllib.request.urlopen(checksum_url) as response:
            checksum_data = response.read().decode('utf-8').strip()
            # Extract just the hash (first part before any whitespace)
            return checksum_data.split()[0] if checksum_data else None
    except Exception:
        return None

def install_oras_binary(prefix='/usr/local/bin', checksum=None):
    """Install ORAS binary from official GitHub releases"""
    arch = detect_arch()
    if not arch:
        print('unsupported architecture for ORAS binary installation')
        return False

    # Map our arch names to ORAS release naming
    oras_arch = arch.replace('-', '_')  # linux-amd64 -> linux_amd64, linux-arm64 -> linux_arm64
    oras_version = 'v1.3.0'
    tarball_name = f'oras_{oras_version[1:]}_{oras_arch}.tar.gz'  # oras_1.3.0_linux_amd64.tar.gz
    download_url = f'https://github.com/oras-project/oras/releases/download/{oras_version}/{tarball_name}'

    binary_path = os.path.join(prefix, 'oras')

    # Check if ORAS is already installed as proper binary
    if os.path.exists(binary_path):
        try:
            result = subprocess.run(['file', binary_path], capture_output=True, text=True, timeout=5)
            if 'ELF 64-bit' in result.stdout:
                print(f'ORAS binary already installed at {binary_path}')
                return True
            else:
                print(f'existing ORAS at {binary_path} is not a proper binary, replacing...')
        except Exception:
            pass

    print(f'downloading ORAS {oras_version} for {oras_arch}')

    # Download and extract
    try:
        with tempfile.TemporaryDirectory() as tmpdir:
            tarball_path = os.path.join(tmpdir, tarball_name)
            print(f'downloading {download_url}')
            subprocess.check_call(['curl', '-fsSL', download_url, '-o', tarball_path])

            # Verify checksum if provided
            if checksum:
                print('verifying ORAS checksum')
                with open(tarball_path, 'rb') as f:
                    h = hashlib.sha256(f.read()).hexdigest()
                if h.lower() != checksum.lower():
                    print(f'checksum mismatch for ORAS: {h} != {checksum}')
                    return False
            else:
                print('no checksum provided for ORAS; skipping verification')

            # Extract tarball
            print('extracting ORAS binary')
            subprocess.check_call(['tar', 'xzf', tarball_path, '-C', tmpdir])

            extracted_binary = os.path.join(tmpdir, 'oras')
            if not os.path.exists(extracted_binary):
                print('ORAS binary not found in extracted tarball')
                return False

            # Install binary
            if not os.access(prefix, os.W_OK):
                if shutil.which('sudo'):
                    print(f'installing ORAS to {binary_path} (with sudo)')
                    subprocess.check_call(['sudo', 'install', '-m', '0755', extracted_binary, binary_path])
                else:
                    # Fallback to ~/.local/bin
                    fallback_prefix = os.path.join(os.path.expanduser('~'), '.local', 'bin')
                    os.makedirs(fallback_prefix, exist_ok=True)
                    fallback_path = os.path.join(fallback_prefix, 'oras')
                    shutil.copy2(extracted_binary, fallback_path)
                    os.chmod(fallback_path, 0o755)
                    print(f'installed ORAS to {fallback_path}')
                    print(f'add {fallback_prefix} to your PATH: export PATH={fallback_prefix}:$PATH')
            else:
                shutil.copy2(extracted_binary, binary_path)
                os.chmod(binary_path, 0o755)
                print(f'installed ORAS to {binary_path}')

            return True

    except subprocess.CalledProcessError as e:
        print(f'ORAS installation failed: {e}')
        return False
    except Exception as e:
        print(f'error installing ORAS: {e}')
        return False

def install_hhfab_via_oras(prefix='/usr/local/bin'):
    """Install hhfab using ORAS from GHCR"""
    # Ensure ORAS is available first
    oras_binary = shutil.which('oras')
    if not oras_binary:
        print('ORAS not found; please install ORAS first')
        return False

    arch = detect_arch()
    if not arch:
        print('unsupported architecture for hhfab installation')
        return False

    # Map our arch names to hhfab image naming
    hhfab_arch = arch  # Keep as linux-amd64 or linux-arm64
    hhfab_version = 'v0.41.3'
    hhfab_image = f'ghcr.io/githedgehog/fabricator/hhfab-{hhfab_arch}:{hhfab_version}'

    binary_path = os.path.join(prefix, 'hhfab')

    print(f'installing hhfab {hhfab_version} for {hhfab_arch} using ORAS')

    try:
        with tempfile.TemporaryDirectory() as tmpdir:
            print(f'pulling {hhfab_image}')
            subprocess.check_call(['oras', 'pull', '-o', tmpdir, hhfab_image])

            extracted_binary = os.path.join(tmpdir, 'hhfab')
            if not os.path.exists(extracted_binary):
                print('hhfab binary not found in pulled artifact')
                return False

            # Install binary
            if not os.access(prefix, os.W_OK):
                if shutil.which('sudo'):
                    print(f'installing hhfab to {binary_path} (with sudo)')
                    subprocess.check_call(['sudo', 'install', '-m', '0755', extracted_binary, binary_path])
                else:
                    # Fallback to ~/.local/bin
                    fallback_prefix = os.path.join(os.path.expanduser('~'), '.local', 'bin')
                    os.makedirs(fallback_prefix, exist_ok=True)
                    fallback_path = os.path.join(fallback_prefix, 'hhfab')
                    shutil.copy2(extracted_binary, fallback_path)
                    os.chmod(fallback_path, 0o755)
                    print(f'installed hhfab to {fallback_path}')
                    print(f'add {fallback_prefix} to your PATH: export PATH={fallback_prefix}:$PATH')
            else:
                shutil.copy2(extracted_binary, binary_path)
                os.chmod(binary_path, 0o755)
                print(f'installed hhfab to {binary_path}')

            return True

    except subprocess.CalledProcessError as e:
        print(f'hhfab installation failed: {e}')
        return False
    except Exception as e:
        print(f'error installing hhfab: {e}')
        return False

def download_and_install_binary(url, binary_name, prefix, checksum=None, retry_count=1):
    """Download binary to temp file and install with proper permissions"""
    dest = os.path.join(prefix, binary_name)
    print(f'installing {binary_name} -> {dest}')

    # Check prefix permissions and prepare fallback
    use_sudo = False
    if not os.access(prefix, os.W_OK):
        if shutil.which('sudo'):
            use_sudo = True
        else:
            # Fallback to ~/.local/bin
            fallback_prefix = os.path.join(os.path.expanduser('~'), '.local', 'bin')
            os.makedirs(fallback_prefix, exist_ok=True)
            dest = os.path.join(fallback_prefix, binary_name)
            print(f'prefix not writable and sudo not available; installing to {dest}')
            print(f'add {fallback_prefix} to your PATH: export PATH={fallback_prefix}:$PATH')

    # Download to temp file with retry
    for attempt in range(retry_count + 1):
        try:
            with tempfile.NamedTemporaryFile(delete=False) as tmp:
                print(f'downloading {binary_name} from {url} (attempt {attempt + 1})')
                subprocess.check_call(['curl', '-fsSL', url, '-o', tmp.name])

                # Verify checksum if provided
                if checksum:
                    print(f'verifying {binary_name} checksum')
                    with open(tmp.name, 'rb') as fh:
                        h = hashlib.sha256(fh.read()).hexdigest()
                    if h.lower() != checksum.lower():
                        print(f'checksum mismatch for {binary_name}: {h} != {checksum}')
                        os.unlink(tmp.name)
                        return False
                else:
                    print(f'no checksum provided for {binary_name}; skipping verification')

                # Install binary
                if use_sudo:
                    subprocess.check_call(['sudo', 'install', '-m', '0755', tmp.name, dest])
                else:
                    shutil.copy2(tmp.name, dest)
                    os.chmod(dest, 0o755)

                os.unlink(tmp.name)
                print(f'installed {dest}')
                return True

        except subprocess.CalledProcessError as e:
            if attempt < retry_count:
                print(f'{binary_name} download failed (attempt {attempt + 1}), retrying...')
                continue
            else:
                print(f'{binary_name} install failed: {e}')
                if 'tmp' in locals():
                    try:
                        os.unlink(tmp.name)
                    except:
                        pass
                return False

    return False

def write_config(portal_base, token, system_mode=False):
    p = ensure_hh_dir()
    user_config_path = os.path.join(p, 'config.json')

    # Minimal, reliable config - only write required fields
    cfg = {
        'lease_url': f"{portal_base}/lease",  # required for helper
        'token': token                        # required for helper
    }

    # Always write user config
    with open(user_config_path, 'w') as f:
        json.dump(cfg, f, indent=2)
    print('wrote', user_config_path)

    # Also write system config if system mode
    if system_mode:
        write_system_config(portal_base, token)

def write_system_config(portal_base, token):
    system_dir = '/etc/hh'
    system_config_path = os.path.join(system_dir, 'config.json')

    # Minimal, reliable system config - only write required fields
    cfg = {
        'lease_url': f"{portal_base}/lease",  # required for helper
        'token': token                        # required for helper
    }

    try:
        # Create system directory (requires sudo)
        subprocess.check_call(['sudo', 'mkdir', '-p', system_dir])

        # Write config to temp file first
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.json') as tmp:
            json.dump(cfg, tmp, indent=2)
            tmp_path = tmp.name

        # Move to system location with proper permissions (requires sudo)
        subprocess.check_call(['sudo', 'mv', tmp_path, system_config_path])
        subprocess.check_call(['sudo', 'chown', 'root:root', system_config_path])
        subprocess.check_call(['sudo', 'chmod', '0640', system_config_path])

        print(f'wrote {system_config_path} (system)')

    except subprocess.CalledProcessError as e:
        print(f'failed to write system config: {e}')
        print('sudo access required for system mode')
        sys.exit(1)
    except Exception as e:
        print(f'error writing system config: {e}')
        sys.exit(1)

def read_config():
    p = os.path.join(os.path.expanduser('~'), '.hh', 'config.json')
    if not os.path.exists(p):
        return None
    with open(p, 'r') as f:
        return json.load(f)

def merge_docker_credhelper(system_mode=False):
    # Always merge user Docker config
    docker_dir = os.path.join(os.path.expanduser('~'), '.docker')
    os.makedirs(docker_dir, exist_ok=True)
    cfg_path = os.path.join(docker_dir, 'config.json')
    if not os.path.exists(cfg_path):
        with open(cfg_path, 'w') as f:
            json.dump({}, f)
    # backup
    shutil.copyfile(cfg_path, cfg_path + '.bak')
    with open(cfg_path, 'r') as f:
        try:
            cfg = json.load(f)
        except Exception:
            cfg = {}
    cred = cfg.get('credHelpers', {}) or {}
    cred['ghcr.io'] = 'hh'
    cfg['credHelpers'] = cred
    with open(cfg_path, 'w') as f:
        json.dump(cfg, f, indent=2)
    print('merged', cfg_path)

    # Also merge system Docker config if system mode
    if system_mode:
        merge_system_docker_config()

def merge_system_docker_config():
    """Merge credHelpers into /root/.docker/config.json for sudo docker support"""
    system_docker_dir = '/root/.docker'
    system_cfg_path = os.path.join(system_docker_dir, 'config.json')

    try:
        # Create system docker directory
        subprocess.check_call(['sudo', 'mkdir', '-p', system_docker_dir])

        # Check if config exists
        config_exists = subprocess.call(['sudo', 'test', '-f', system_cfg_path]) == 0

        if not config_exists:
            # Create empty config
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.json') as tmp:
                json.dump({}, tmp)
                tmp_path = tmp.name
            subprocess.check_call(['sudo', 'mv', tmp_path, system_cfg_path])
        else:
            # Backup existing config
            subprocess.check_call(['sudo', 'cp', system_cfg_path, system_cfg_path + '.bak'])

        # Read current config
        try:
            result = subprocess.check_output(['sudo', 'cat', system_cfg_path])
            cfg = json.loads(result.decode('utf-8'))
        except (subprocess.CalledProcessError, json.JSONDecodeError):
            cfg = {}

        # Merge credHelpers
        cred = cfg.get('credHelpers', {}) or {}
        cred['ghcr.io'] = 'hh'
        cfg['credHelpers'] = cred

        # Write updated config
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.json') as tmp:
            json.dump(cfg, tmp, indent=2)
            tmp_path = tmp.name

        subprocess.check_call(['sudo', 'mv', tmp_path, system_cfg_path])
        subprocess.check_call(['sudo', 'chown', 'root:root', system_cfg_path])
        subprocess.check_call(['sudo', 'chmod', '0600', system_cfg_path])

        print(f'merged {system_cfg_path} (system)')

    except subprocess.CalledProcessError as e:
        print(f'failed to merge system Docker config: {e}')
        print('continuing without system Docker config')
    except Exception as e:
        print(f'error merging system Docker config: {e}')
        print('continuing without system Docker config')

def check_docker():
    # ensure docker is available and accessible
    d = shutil.which('docker')
    if not d:
        print('docker not found â€” please install Docker: https://docs.docker.com/get-docker/')
        return False, 'missing'

    # First try docker info (preferred over docker version)
    try:
        subprocess.check_output(['docker', 'info'], stderr=subprocess.STDOUT, timeout=10)
        return True, 'ok'
    except subprocess.CalledProcessError as e:
        s = e.output.decode('utf8', 'replace')
        if 'permission denied' in s.lower() or 'connect to the docker daemon socket' in s.lower():
            return False, 'permission'
        print('docker appears broken:', s)
        return False, 'broken'
    except Exception as e:
        print('docker check failed:', str(e))
        return False, 'error'

def download_and_verify_helper(helper_url, checksum=None, is_shell_script=False):
    """Download helper from release URL and verify checksum if provided"""
    print(f'downloading helper from {helper_url}')
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix='.sh' if is_shell_script else '') as tmp:
            subprocess.check_call(['curl', '-fsSL', helper_url, '-o', tmp.name])
            if checksum:
                print('verifying helper checksum')
                with open(tmp.name, 'rb') as fh:
                    h = hashlib.sha256(fh.read()).hexdigest()
                if h.lower() != checksum.lower():
                    print(f'checksum mismatch for helper {h} != {checksum}')
                    os.unlink(tmp.name)
                    return None
            else:
                print('no checksum provided; skipping verification')
            return tmp.name
    except subprocess.CalledProcessError as e:
        print(f'failed to download helper: {e}')
        return None

def ensure_helper_installed(prefix='/usr/local/bin', no_install=False, helper_url=None, sha256_helper=None):
    helper_path = os.path.join(prefix, 'docker-credential-hh')

    # Check if already installed
    if os.path.exists(helper_path):
        print(f'docker-credential-hh already installed at {helper_path}')
        return True

    # Check if in PATH (different location)
    if shutil.which('docker-credential-hh'):
        print('docker-credential-hh already in PATH')
        return True

    # Try local build first
    local = os.path.join(os.getcwd(), 'cli', 'docker-credential-hh', 'docker-credential-hh')
    helper_source = None

    if os.path.exists(local):
        print(f'using local helper at {local}')
        helper_source = local
    elif helper_url:
        # Download from provided URL
        helper_source = download_and_verify_helper(helper_url, sha256_helper)
        if not helper_source:
            return False
    else:
        # Auto-install: try to fetch from GitHub releases
        default_url, checksum_url, arch_type = get_default_helper_urls()
        print(f'credential helper not found â€” fetching from release ({arch_type})...')

        # Try to fetch checksum first
        checksum = fetch_checksum(checksum_url)
        if not checksum:
            print('no checksum found; skipping verification')

        # Try arch-specific binary first
        helper_source = download_and_verify_helper(default_url, checksum, is_shell_script=(arch_type == "shell"))

        # If arch-specific binary fails and we haven't tried shell script yet, try shell fallback
        if not helper_source and arch_type != "shell":
            print(f'arch-specific binary ({arch_type}) not available, trying shell fallback...')
            fallback_url = f"{DEFAULT_HELPER_BASE_URL}/docker-credential-hh.sh"
            fallback_checksum_url = f"{DEFAULT_HELPER_BASE_URL}/docker-credential-hh.sh.sha256"
            fallback_checksum = fetch_checksum(fallback_checksum_url)
            if not fallback_checksum:
                print('no checksum found for shell fallback; skipping verification')
            helper_source = download_and_verify_helper(fallback_url, fallback_checksum, is_shell_script=True)

        if not helper_source:
            print('failed to download credential helper from release')
            return False

    if no_install:
        print(f'helper available but not installing system-wide (--no-install)')
        if helper_source != local:
            os.unlink(helper_source)
        return True

    # Install helper
    print(f'installing helper to {helper_path}')

    # Check if we can write to prefix
    if not os.access(prefix, os.W_OK):
        if not shutil.which('sudo'):
            print(f'prefix {prefix} is not writable and sudo not available')
            # Try fallback to ~/.local/bin
            fallback_prefix = os.path.join(os.path.expanduser('~'), '.local', 'bin')
            os.makedirs(fallback_prefix, exist_ok=True)
            fallback_path = os.path.join(fallback_prefix, 'docker-credential-hh')

            try:
                shutil.copy2(helper_source, fallback_path)
                os.chmod(fallback_path, 0o755)
                print(f'installed helper to {fallback_path}')
                print(f'add {fallback_prefix} to your PATH: export PATH={fallback_prefix}:$PATH')
                if helper_source != local:
                    os.unlink(helper_source)
                return True
            except Exception as e:
                print(f'failed to install to fallback location: {e}')
                if helper_source != local:
                    os.unlink(helper_source)
                return False

    try:
        subprocess.check_call(['sudo', 'install', '-m', '0755', helper_source, helper_path])
        print(f'installed {helper_path}')
        if helper_source != local:
            os.unlink(helper_source)
        return True
    except subprocess.CalledProcessError as e:
        print(f'failed to install helper: {e}')
        if helper_source != local:
            os.unlink(helper_source)
        return False

def run_sanity_pull(image, ignore_failure=False):
    if not image:
        print('no sanity image provided; skipping pull')
        return True
    # try logout then pull
    subprocess.call(['docker', 'logout', 'ghcr.io'])
    try:
        subprocess.check_call(['docker', 'pull', image])
        print('pulled', image)
        return True
    except subprocess.CalledProcessError as e:
        out = str(e)
        if 'manifest unknown' in out.lower() or 'manifest unknown' in e.__repr__().lower():
            print('image/tag likely does not exist (manifest unknown):', image)
            return ignore_failure
        print('docker pull failed:', out)
        return ignore_failure

def run_oras_sanity_check():
    """Run ORAS sanity check with a public image"""
    oras_binary = shutil.which('oras')
    if not oras_binary:
        print('oras not found; skipping ORAS sanity check')
        return True

    # Test with a known public image
    test_image = 'ghcr.io/githedgehog/fabricator/hhfab-linux-amd64:v0.41.3'
    print(f'testing ORAS with public image: {test_image}')

    try:
        # Try to pull with ORAS (this should work with anonymous access)
        result = subprocess.run(
            ['oras', 'pull', test_image, '--dry-run'],
            capture_output=True,
            text=True,
            timeout=30
        )

        if result.returncode == 0:
            print('âœ“ ORAS sanity check passed')
            return True
        else:
            # Check if it's an auth issue
            if 'authentication' in result.stderr.lower() or 'unauthorized' in result.stderr.lower():
                print('âš  Credential helper could not lease a token; falling back to anonymous.')
                print('  If this is a private repo, ensure your pairing code is valid.')
                # Try without credential helper
                env = os.environ.copy()
                env.pop('DOCKER_CONFIG', None)  # Remove Docker config to bypass credential helper
                result_anon = subprocess.run(
                    ['oras', 'pull', test_image, '--dry-run'],
                    capture_output=True,
                    text=True,
                    timeout=30,
                    env=env
                )
                if result_anon.returncode == 0:
                    print('âœ“ Anonymous fallback works')
                    return True

            print(f'ORAS sanity check failed: {result.stderr.strip()}')
            return False

    except subprocess.TimeoutExpired:
        print('ORAS sanity check timed out')
        return False
    except Exception as e:
        print(f'ORAS sanity check error: {e}')
        return False

def cmd_version(args):
    """Print version information"""
    print(f'hh {HH_VERSION}')

    # Show commit info
    commit = HH_COMMIT
    if commit == 'unknown':
        try:
            # Try to get current git commit
            result = subprocess.run(['git', 'rev-parse', '--short', 'HEAD'],
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                commit = result.stdout.strip()
        except:
            pass

    if commit != 'unknown':
        print(f'commit: {commit}')

    # Show build date
    build_date = HH_BUILD_DATE
    if build_date == 'unknown':
        try:
            from datetime import datetime
            build_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')
        except:
            pass

    if build_date != 'unknown':
        print(f'built: {build_date}')

def cmd_doctor(args):
    """Run diagnostic checks"""
    print(f'hh {HH_VERSION}')
    if HH_COMMIT != 'unknown':
        print(f'commit: {HH_COMMIT}')

    print('')

    # Check Docker
    print('ðŸ” Checking Docker...')
    ok, reason = check_docker()
    if ok:
        print('âœ… Docker is accessible')
    else:
        if reason == 'missing':
            print('âŒ Docker not found - please install Docker')
        elif reason == 'permission':
            print('âš ï¸  Docker requires elevated privileges (consider: sudo usermod -aG docker $USER)')
        else:
            print(f'âŒ Docker check failed: {reason}')

    # Check credential helper
    print('')
    print('ðŸ” Checking credential helper...')
    helper_path = shutil.which('docker-credential-hh')
    if helper_path:
        print(f'âœ… Helper found at: {helper_path}')
    else:
        print('âŒ docker-credential-hh not found in PATH')

    # Check config
    print('')
    print('ðŸ” Checking configuration...')
    config_paths = [
        os.path.join(os.path.expanduser('~'), '.hh', 'config.json'),
        '/etc/hh/config.json'
    ]

    config_found = False
    for config_path in config_paths:
        if os.path.exists(config_path):
            print(f'âœ… Config found: {config_path}')
            try:
                with open(config_path, 'r') as f:
                    cfg = json.load(f)
                required_keys = ['lease_url', 'edge_auth', 'token']
                missing_keys = [k for k in required_keys if not cfg.get(k)]
                if missing_keys:
                    print(f'âš ï¸  Missing config keys: {", ".join(missing_keys)}')
                else:
                    print('âœ… All required config keys present')
                config_found = True
                break
            except Exception as e:
                print(f'âŒ Error reading config: {e}')

    if not config_found:
        print('âŒ No config file found - run "hh login" first')

    # Test credential helper
    if helper_path and config_found:
        print('')
        print('ðŸ” Testing credential helper...')
        try:
            result = subprocess.run(
                [helper_path, 'get'],
                input='ghcr.io\n',
                capture_output=True,
                text=True,
                timeout=10
            )
            if result.returncode == 0 and result.stdout.strip():
                print('âœ… Helper returned credentials')
            elif result.returncode == 0 and not result.stdout.strip():
                print('âš ï¸  Helper returned no credentials (anonymous fallback)')
            else:
                print(f'âŒ Helper failed with exit code {result.returncode}')
        except Exception as e:
            print(f'âŒ Error testing helper: {e}')

    # Check ORAS
    print('')
    print('ðŸ” Checking ORAS...')
    oras_path = shutil.which('oras')
    if oras_path:
        try:
            result = subprocess.run([oras_path, 'version'], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                print(f'âœ… ORAS found at: {oras_path}')
                # Check if it's an ELF binary
                file_result = subprocess.run(['file', oras_path], capture_output=True, text=True)
                if 'ELF' in file_result.stdout:
                    print('âœ… ORAS is a proper binary (not a script)')
                else:
                    print('âš ï¸  ORAS appears to be a script, not a binary')
            else:
                print(f'âŒ ORAS failed to run: {result.stderr}')
        except Exception as e:
            print(f'âŒ Error checking ORAS: {e}')
    else:
        print('âš ï¸  ORAS not found in PATH')

    # Test public pull
    print('')
    print('ðŸ” Testing public registry access...')
    try:
        result = subprocess.run(
            ['docker', 'pull', 'hello-world'],
            capture_output=True,
            text=True,
            timeout=30
        )
        if result.returncode == 0:
            print('âœ… Public Docker pull works')
        else:
            print('âŒ Public Docker pull failed')
    except Exception as e:
        print(f'âŒ Error testing public pull: {e}')

def cmd_login(args):
    # Support both positional and --code arguments
    # --code flag takes precedence over positional argument
    token = getattr(args, 'code', None)  # This gets the --code flag
    if not token:
        token = getattr(args, 'pairing_code', None)  # This gets the positional argument
    if not token:
        token = input('pairing code: ').strip()
    portal = args.portal or DEFAULT_PORTAL
    system_mode = getattr(args, 'system', False)
    write_config(portal, token, system_mode)

def cmd_download(args):
    # deprecated flag handling
    if getattr(args, 'no_install', False):
        print('[deprecation] --no-install is ignored; use --no-hhfab/--no-oras/--no-helper', file=sys.stderr)

    cfg = read_config()
    if not cfg:
        print('no ~/.hh/config.json; running login')
        cmd_login(args)
        cfg = read_config()
    token = cfg.get('token') or cfg.get('download_token')
    portal = cfg.get('lease_url', DEFAULT_PORTAL).replace('/lease', '') or cfg.get('portal_base', DEFAULT_PORTAL)
    if not token:
        print('no token in ~/.hh/config.json; run hh login first')
        return 1

    system_mode = getattr(args, 'system', False)

    # pre-flight checks: Docker permissions
    ok, reason = check_docker()
    if not ok:
        if reason == 'missing':
            return EC_DOCKER_MISSING
        if reason == 'permission':
            print('Docker requires elevated privileges. Choose one:')
            print('  (a) Recommended: sudo usermod -aG docker $USER && newgrp docker')
            print('  (b) System mode: hh login --system && hh download --system')
            if not system_mode and not args.ignore_sanity_failure:
                return EC_DOCKER_SUDO_REQUIRED

    # ensure helper
    if not args.no_helper:
        helper_url = getattr(args, 'helper_url', None)
        sha256_helper = getattr(args, 'sha256_helper', None)
        if not ensure_helper_installed(
            prefix=args.prefix,
            no_install=getattr(args, 'no_install', False),
            helper_url=helper_url,
            sha256_helper=sha256_helper
        ):
            print('failed to ensure credential helper')
            return EC_HELPER_INSTALL_FAILED

    # merge docker config non-destructively
    merge_docker_credhelper(system_mode)

    # install oras first (required for hhfab installation)
    if not args.no_oras:
        if not install_oras_binary(
            prefix=args.prefix,
            checksum=args.sha256_oras
        ):
            return EC_BIN_INSTALL_FAILED

    # install hhfab via oras
    if not args.no_hhfab:
        if not install_hhfab_via_oras(prefix=args.prefix):
            return EC_BIN_INSTALL_FAILED

    # sanity pull
    if args.sanity:
        ok_pull = run_sanity_pull(args.sanity, ignore_failure=args.ignore_sanity_failure)
        if not ok_pull:
            return 7

    # ORAS sanity check (optional)
    if args.oras_sanity:
        run_oras_sanity_check()  # Always continue regardless of result

    # friendly message
    print('\nâœ… hh is ready.')
    print('\nNext steps:')
    print('  mkdir -p ~/hhfab-dir && cd ~/hhfab-dir')
    print('  hhfab init --dev')
    print('  hhfab vlab gen')
    print('  hhfab build')
    return EC_SUCCESS

def main():
    p = argparse.ArgumentParser(prog='hh')
    p.add_argument('--version', action='store_true', help='Show version information')
    sp = p.add_subparsers(dest='cmd')

    p_version = sp.add_parser('version', help='Show version information')
    p_version.set_defaults(func=cmd_version)

    p_doctor = sp.add_parser('doctor', help='Run diagnostic checks')
    p_doctor.set_defaults(func=cmd_doctor)

    p_login = sp.add_parser('login')
    p_login.add_argument('pairing_code', nargs='?', help='Pairing code (positional argument)')
    p_login.add_argument('--code', help='Pairing code (--code flag, overrides positional)')
    p_login.add_argument('--portal')
    p_login.add_argument('--system', action='store_true', help='Write config to /etc/hh/config.json for sudo docker support')
    p_login.set_defaults(func=cmd_login)

    p_down = sp.add_parser('download', help='Install helper and optional binaries; see examples below',
                           description='Install helper and optional binaries')
    p_down.add_argument('--sanity')
    p_down.add_argument('--ignore-sanity-failure', action='store_true')
    p_down.add_argument('--oras-sanity', action='store_true', help='Test ORAS with public image after installation')
    p_down.add_argument('--prefix', default='/usr/local/bin')
    p_down.add_argument('--system', action='store_true', help='Configure for sudo docker support (requires system config)')
    p_down.add_argument('--helper-url', dest='helper_url', help='URL to download credential helper from release')
    p_down.add_argument('--sha256-helper', dest='sha256_helper', help='SHA256 checksum for credential helper')
    p_down.add_argument('--hhfab-url', dest='hhfab_url', default='https://i.hhdev.io/hhfab')
    p_down.add_argument('--oras-url', dest='oras_url', default='https://i.hhdev.io/oras')
    p_down.add_argument('--sha256-hhfab', dest='sha256_hhfab')
    p_down.add_argument('--sha256-oras', dest='sha256_oras')
    p_down.add_argument('--no-hhfab', action='store_true')
    p_down.add_argument('--no-oras', action='store_true')
    p_down.add_argument('--no-helper', action='store_true')
    # deprecated: accept but hide --no-install
    p_down.add_argument('--no-install', action='store_true', help=argparse.SUPPRESS)
    # examples
    p_down.epilog = 'Examples:\n  hh download --no-hhfab --no-oras      # only install the Docker helper\n  hh download --sanity ghcr.io/ORG/IMG:TAG\n  hh download --system                  # configure for sudo docker'
    p_down.set_defaults(func=cmd_download)

    args = p.parse_args()

    # Handle --version flag
    if args.version:
        cmd_version(args)
        return

    if not args.cmd:
        p.print_help()
        sys.exit(2)
    args.func(args)

if __name__ == '__main__':
    main()
